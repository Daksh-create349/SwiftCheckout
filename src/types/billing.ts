
import { z } from 'zod';

export interface Product { // Represents a product generally, could be from AI or future DB
  id: string; // Can be a generated ID for items not in a DB
  name: string;
  price: number;
  stock?: number;
}

export interface CartItem {
  id: string; // Unique ID for the cart item instance
  productId: string; // Can be the AI identified name or a generated ID if no formal product catalog ID exists
  name: string;
  price: number; // Price per unit, can be the AI's price or manually overridden price
  quantity: number;
  originalPrice: number; // AI's initial estimated price or catalog price if available
}

export interface Currency {
  code: string;
  symbol: string;
  name: string;
}

export const BillRecordSchema = z.object({
  id: z.string(),
  date: z.string(),
  items: z.array(z.object({
    id: z.string(),
    productId: z.string(),
    name: z.string(),
    price: z.number(),
    quantity: z.number(),
    originalPrice: z.number(),
  })),
  subtotal: z.number(),
  discountAmount: z.number(),
  taxAmount: z.number(),
  grandTotal: z.number(),
  currencySymbol: z.string(),
  billImageDataUri: z.string().nullable(),
});
export type BillRecord = z.infer<typeof BillRecordSchema>;


export const SUPPORTED_CURRENCIES: Currency[] = [
  { code: 'USD', symbol: '$', name: 'US Dollar' },
  { code: 'EUR', symbol: '€', name: 'Euro' },
  { code: 'GBP', symbol: '£', name: 'British Pound' },
  { code: 'JPY', symbol: '¥', name: 'Japanese Yen' },
  { code: 'INR', symbol: '₹', name: 'Indian Rupee' },
];

export const DEFAULT_CURRENCY_CODE = 'USD';

export function getCurrencySymbol(code: string | undefined): string {
  if (!code) return SUPPORTED_CURRENCIES.find(c => c.code === DEFAULT_CURRENCY_CODE)?.symbol || '$';
  const currency = SUPPORTED_CURRENCIES.find(c => c.code === code);
  return currency ? currency.symbol : SUPPORTED_CURRENCIES.find(c => c.code === DEFAULT_CURRENCY_CODE)?.symbol || '$';
}

export function getCurrencyCode(symbol: string | undefined): string {
    if (!symbol) return DEFAULT_CURRENCY_CODE;
    const currency = SUPPORTED_CURRENCIES.find(c => c.symbol === symbol);
    return currency ? currency.code : DEFAULT_CURRENCY_CODE;
}

// Schemas for Sales Analysis Flow
export const AnalyzeSalesInputSchema = z.object({
  billHistory: z.array(BillRecordSchema).describe("An array of past bill records to be analyzed."),
  currencyCode: z.string().describe("The currency code for summarizing financial data (e.g., USD, EUR)."),
});

const SalesMetricSchema = z.object({
    totalRevenue: z.number().describe("The total revenue from all bills."),
    totalBills: z.number().describe("The total number of bills processed."),
    averageBillValue: z.number().describe("The average value of a single bill."),
});

const ProductPerformanceSchema = z.object({
    name: z.string().describe("The name of the product."),
    quantitySold: z.number().describe("Total quantity of the product sold."),
    revenueGenerated: z.number().describe("Total revenue generated by this product."),
});

const DailySalesSchema = z.object({
    date: z.string().describe("The date of sales (YYYY-MM-DD)."),
    totalRevenue: z.number().describe("Total revenue for that day."),
});

export const AnalyzeSalesOutputSchema = z.object({
  metrics: SalesMetricSchema.describe("Key performance indicators from the sales data."),
  topSellingProducts: z.array(ProductPerformanceSchema).describe("A list of the best-selling products, sorted by revenue."),
  dailySales: z.array(DailySalesSchema).describe("A summary of total revenue per day."),
  aiSummary: z.string().describe("A natural language summary of the key sales insights, trends, and takeaways."),
});

export type AnalyzeSalesInput = z.infer<typeof AnalyzeSalesInputSchema>;
export type AnalyzeSalesOutput = z.infer<typeof AnalyzeSalesOutputSchema>;
export type DailySales = z.infer<typeof DailySalesSchema>;


// Schemas for Voice Command Flow
export const InterpretVoiceCommandInputSchema = z.object({
  audioDataUri: z
    .string()
    .describe(
      "A recording of a user's voice command, as a data URI that must include a MIME type and use Base64 encoding. Expected format: 'data:audio/wav;base64,<encoded_data>'"
    ),
  currencyCode: z.string().describe('The currency code for the price estimate (e.g., USD, EUR, JPY).'),
});
export type InterpretVoiceCommandInput = z.infer<typeof InterpretVoiceCommandInputSchema>;


export const IdentifiedItemSchema = z.object({
    name: z.string().describe('The common name of the identified product.'),
    price: z.number().describe('The estimated market price in the specified currency for the product.'),
    quantity: z.number().describe('The quantity of the item to add.'),
    originalPrice: z.number().describe("The original estimated price, for reference."),
});
export type IdentifiedItem = z.infer<typeof IdentifiedItemSchema>;

export const InterpretVoiceCommandOutputSchema = z.object({
    transcribedText: z.string().describe("The text transcribed from the audio."),
    itemsToAdd: z.array(IdentifiedItemSchema).describe("A list of structured items to be added to the cart."),
});
export type InterpretVoiceCommandOutput = z.infer<typeof InterpretVoiceCommandOutputSchema>;

// Schema for the AI's interpretation of the text
export const VoiceInterpretationSchema = z.object({
    items: z.array(z.object({
        productName: z.string().describe("The name of the product mentioned."),
        quantity: z.number().describe("The quantity of that product."),
    })).describe("A list of products and quantities extracted from the user's command."),
});
